<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dungeon Web Client</title>
    <style>
        html, body { height: 100%; margin: 0; background: #0b0e13; color: #dbe2f1; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .wrap { display: flex; flex-direction: column; gap: 8px; padding: 12px; max-width: 920px; margin: 0 auto; }
        .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        input, button, select { background: #121722; color: #e8eefc; border: 1px solid #2b3342; border-radius: 6px; padding: 8px 10px; font: inherit; }
        button { cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .status { font-size: 12px; opacity: 0.8; }
        canvas { background: #0e141f; border: 1px solid #2b3342; border-radius: 6px; image-rendering: pixelated; }
        .hint { font-size: 12px; color: #9fb2d6; }
        .row > * { flex: 0 0 auto; }
        .spacer { flex: 1 1 auto; }

        /* Responsive: allow canvas to scale to viewport on small screens */
        @media (max-width: 920px) {
            canvas { width: 100%; height: auto; max-width: 100%; }
            .wrap { padding: 10px; }
        }

        /* Mobile touch controls overlay (hidden by default, enabled via JS for coarse pointers) */
        #touchControls { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: none; }
        .touch { pointer-events: auto; touch-action: none; }
        .touch-btn { position: absolute; width: 54px; height: 54px; background: rgba(18, 23, 34, 0.6); border: 1px solid #2b3342; border-radius: 12px; }
        .touch-btn.active { background: rgba(99, 102, 241, 0.6); border-color: #6366f1; }

        .dpad { position: fixed; left: 16px; bottom: 16px; width: 160px; height: 160px; }
        .dpad .up { left: 53px; top: 0; }
        .dpad .down { left: 53px; bottom: 0; }
        .dpad .left { left: 0; top: 53px; }
        .dpad .right { right: 0; top: 53px; }

        .shoot { position: fixed; right: 16px; bottom: 36px; width: 84px; height: 84px; background: rgba(18, 23, 34, 0.6); border: 1px solid #2b3342; border-radius: 50%; }
        .shoot.active { background: rgba(34, 197, 94, 0.6); border-color: #22c55e; }

        /* Respect iOS safe areas */
        @supports (padding: env(safe-area-inset-bottom)) {
            .dpad { bottom: calc(16px + env(safe-area-inset-bottom)); }
            .shoot { bottom: calc(36px + env(safe-area-inset-bottom)); }
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="row">
        <input id="serverUrl" type="text" placeholder="wss://host[:port]/path" value="wss://runcode.at/ws" style="min-width:320px" />
        <button id="connect">Connect</button>
        <button id="disconnect" disabled>Disconnect</button>
        <div class="spacer"></div>
        <div id="status" class="status">Idle</div>
    </div>
    <canvas id="view" width="800" height="480"></canvas>
    <div class="hint">Controls: WASD/Arrows to move, Space to shoot, Q to quit. On mobile, use on-screen controls.</div>
</div>

<!-- Mobile touch controls overlay (enabled only on coarse-pointer devices) -->
<div id="touchControls" aria-hidden="true">
    <div class="touch dpad" id="dpad">
        <button id="btnUp" class="touch-btn up" aria-label="Up"></button>
        <button id="btnLeft" class="touch-btn left" aria-label="Left"></button>
        <button id="btnRight" class="touch-btn right" aria-label="Right"></button>
        <button id="btnDown" class="touch-btn down" aria-label="Down"></button>
    </div>
    <button id="btnShoot" class="touch shoot" aria-label="Shoot"></button>
    
    <!-- Prevent default context menu on long-press -->
    <script>
    // Prevent context menu while interacting with touch controls
    document.addEventListener('contextmenu', function (e) {
        const tc = document.getElementById('touchControls');
        if (!tc) return;
        if (tc.style.display === 'block') { e.preventDefault(); }
    });
    </script>
</div>

<script>
(() => {
    "use strict";

    // Constants aligned with C/types.h
    const MAP_WIDTH = 40;
    const MAP_HEIGHT = 18;
    const WORLD_W = 9;
    const WORLD_H = 9;
    const TILE_SIZE = 16; // pixels per tile in canvas
    const VIEW_TILE_W = MAP_WIDTH;
    const VIEW_TILE_H = MAP_HEIGHT + 14; // extra HUD rows for HUD + scoreboard + minimap
    const CANVAS_W = VIEW_TILE_W * TILE_SIZE;
    const CANVAS_H = VIEW_TILE_H * TILE_SIZE;

    const canvas = document.getElementById("view");
    const ctx = canvas.getContext("2d");
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;

    const statusEl = document.getElementById("status");
    const btnConnect = document.getElementById("connect");
    const btnDisconnect = document.getElementById("disconnect");
    const serverUrlInput = document.getElementById("serverUrl");
    const touchControlsEl = document.getElementById("touchControls");
    const btnUp = document.getElementById("btnUp");
    const btnDown = document.getElementById("btnDown");
    const btnLeft = document.getElementById("btnLeft");
    const btnRight = document.getElementById("btnRight");
    const btnShoot = document.getElementById("btnShoot");

    let socket = null;
    let youId = -1;
    let lastPingAt = 0;
    let pingMs = -1;
    const pingOutstanding = Object.create(null);
    // WS snapshots are full lines per message; we parse per-message for lower GC
    let netDirty = false;
    let pingTimer = null;
    let inputTimer = null;
    // Track whether the current map (world tile) is fully received
    let initialMapLoaded = false;
    const MIN_LOADING_MS = 500; // match console minimal loading duration
    let loadingStartAt = 0;
    let loadingAnimTick = 0;
    let currentWorldX = -1, currentWorldY = -1;
    let joined = false; // becomes true after we receive our PLAYER line with active=1
    // Client tick counter for interpolation/extrapolation; declared early to avoid TDZ in handlers
    let gameTick = 0;
    // Per-message marker to track which bullets were seen in the latest snapshot
    let currentBulletBatchId = 0;
    // Client-side prediction state
    let lastSentInput = { dx: 0, dy: 0, shoot: 0 };
    let lastInputSentAt = 0;
    let lastPredictedMoveAt = 0;
    let prevShootState = 0;
    let lastLocalShotAt = 0;
    let myFacing = { dx: 1, dy: 0 }; // default facing right
    const MOVE_STEP_MS = 50; // server tick ~50ms
    const SHOOT_COOLDOWN_MS = 400; // matches server (8 * 50ms)
    const PREDICT_BULLET_GRACE_MS = 250; // keep predicted bullets alive until confirmed

    // World state
    const worldTiles = new Array(WORLD_H);
    for (let y = 0; y < WORLD_H; y++) {
        worldTiles[y] = new Array(WORLD_W);
        for (let x = 0; x < WORLD_W; x++) {
            worldTiles[y][x] = new Array(MAP_HEIGHT);
            for (let my = 0; my < MAP_HEIGHT; my++) {
                worldTiles[y][x][my] = new Array(MAP_WIDTH).fill('.');
            }
        }
    }

    const players = []; // index by id: {active, wx, wy, x, y, color, hp, invincibleTicks, superTicks, score, _last:{wx,wy,x,y}, _lastUpdateTick:number}
    const bullets = []; // array of {wx, wy, x, y, active, _last:{wx,wy,x,y}, _lastUpdateTick:number}
    const enemies = []; // array of {wx, wy, x, y, hp}

    // Track per-tile receipt for the current world tile to robustly detect full-load
    let tileRecv = null; // 2D array [MAP_HEIGHT][MAP_WIDTH] of booleans
    let tileRecvCount = 0;
    function resetTileRecv() {
        tileRecv = new Array(MAP_HEIGHT);
        for (let y = 0; y < MAP_HEIGHT; y++) {
            tileRecv[y] = new Array(MAP_WIDTH).fill(false);
        }
        tileRecvCount = 0;
    }
    function resetLoadingTracker() {
        // Trigger loading overlay only for the initial map. For subsequent
        // maps, keep the overlay disabled and only reset per-tile tracking.
        if (!initialMapLoaded) {
            initialMapLoaded = false;
            loadingAnimTick = 0;
            loadingStartAt = performance.now();
            resetTileRecv();
        } else {
            // Subsequent map transitions: no loading overlay
            resetTileRecv();
        }
    }
    function isLoadingActive() {
        if (!joined) return true;
        if (!initialMapLoaded) return true;
        if ((performance.now() - loadingStartAt) < MIN_LOADING_MS) return true;
        return false;
    }

    function setStatus(text) { statusEl.textContent = text; }

    // Default endpoint; can be overridden via input
    const DEFAULT_ENDPOINT = "wss://runcode.at/ws";

    let connectAbort = false;
    async function connect() {
        btnConnect.disabled = true;
        btnDisconnect.disabled = true;
        youId = -1;
        joined = false;
        currentWorldX = -1; currentWorldY = -1; resetLoadingTracker();
        connectAbort = false;

        const target = (serverUrlInput.value && serverUrlInput.value.trim()) ? serverUrlInput.value.trim() : DEFAULT_ENDPOINT;
        const ok = await tryOneEndpoint(target);
        if (!ok) {
            setStatus("Unable to connect to " + target + ". Check server.");
            btnConnect.disabled = false;
        }
    }

    function tryOneEndpoint(url) {
        return new Promise((resolve) => {
            let opened = false;
            setStatus("Connecting: " + url);
            let ws;
            try {
                ws = new WebSocket(url);
            } catch (e) {
                setStatus("WebSocket error constructing: " + e);
                resolve(false);
                return;
            }
            ws.binaryType = "arraybuffer";
            // If using wss:// on non-standard port or behind a proxy, ensure the path is correct
            // and that the server supports WebSocket on that endpoint.
            ws.onopen = () => {
                if (connectAbort) { try { ws.close(); } catch {} resolve(false); return; }
                opened = true;
                socket = ws;
                setStatus("Connected: " + url + " (HELLO)");
                sendLine("HELLO");
                startNetworkTimers();
                btnDisconnect.disabled = false;
                resolve(true);
            };
            ws.onmessage = (ev) => {
                const handleText = (text) => {
                    currentBulletBatchId = (currentBulletBatchId + 1) | 0;
                    enemies.length = 0;
                    const lines = text.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        handleLine(line);
                    }
                    const now = performance.now();
                    for (let i = 0; i < bullets.length; i++) {
                        const b = bullets[i];
                        if (b._seenBatch !== currentBulletBatchId) {
                            if (b.predicted && (now - (b.predictedAt || 0)) < PREDICT_BULLET_GRACE_MS) {
                            } else {
                                b.active = 0;
                            }
                        }
                    }
                    netDirty = true;
                };
                if (typeof ev.data === "string") {
                    handleText(ev.data);
                } else if (ev.data instanceof Blob) {
                    ev.data.text().then(handleText).catch(() => {});
                } else if (ev.data instanceof ArrayBuffer) {
                    try { handleText(new TextDecoder().decode(ev.data)); } catch {}
                } else {
                    try { handleText(String(ev.data || "")); } catch {}
                }
            };
            ws.onerror = () => {
                if (!opened) setStatus("Failed: " + url);
            };
            ws.onclose = (ev) => {
                if (socket === ws) {
                    const code = ev && typeof ev.code === 'number' ? ev.code : 0;
                    const reason = ev && ev.reason ? (" ("+ev.reason+")") : "";
                    setStatus("Disconnected" + (code ? (" ["+code+"]") : "") + reason);
                    btnConnect.disabled = false;
                    btnDisconnect.disabled = true;
                    socket = null;
                    stopNetworkTimers();
                }
                if (!opened) resolve(false); // try next endpoint
            };
        });
    }

    function disconnect() {
        if (socket) {
            try { sendLine("BYE"); } catch {}
            socket.close();
        }
    }

    function sendLine(s) {
        if (!socket || socket.readyState !== 1) return;
        socket.send(s + "\n");
    }

    function clamp(val, lo, hi) { return Math.max(lo, Math.min(hi, val)); }

    // No rolling buffer needed under WS; server frames are per-message

    function ensurePlayersSize(id) {
        while (players.length <= id) players.push({active:0, wx:0, wy:0, x:0, y:0, color:0, hp:0, invincibleTicks:0, superTicks:0, score:0});
    }

    function parseInts(parts, startIndex) {
        const out = [];
        for (let i = startIndex; i < parts.length; i++) out.push(parseInt(parts[i], 10));
        return out;
    }

    function handleLine(line) {
        if (!line) return;
        const parts = line.split(/\s+/);
        const tag = parts[0];
        if (tag === "YOU") {
            if (parts.length >= 2) youId = parseInt(parts[1], 10);
            joined = true;
            if (!loadingStartAt) loadingStartAt = performance.now();
            setStatus(`Joined, you are id ${youId}`);
            return;
        }
        if (tag === "PONG") {
            if (parts.length >= 2) {
                const token = parts.slice(1).join(" ");
                const sentAt = pingOutstanding[token];
                if (sentAt) {
                    pingMs = Math.round(performance.now() - sentAt);
                    delete pingOutstanding[token];
                }
            }
            return;
        }
        if (tag === "FULL") { setStatus("Server full"); return; }
        if (tag === "PLAYER") {
            // PLAYER id wx wy x y color active hp invincibleTicks superTicks score
            if (parts.length < 12) return;
            const [id, wx, wy, x, y, color, active, hp, invTicks, superTicks, score] = parseInts(parts, 1);
            ensurePlayersSize(id);
            const p = players[id];
            const hadPrev = (p._lastUpdateTick !== undefined);
            if (hadPrev) p._last = { wx: p.wx, wy: p.wy, x: p.x, y: p.y };
            Object.assign(p, { wx, wy, x, y, color, active, hp, invincibleTicks: invTicks, superTicks, score });
            p._lastUpdateTick = gameTick;
            if (id === youId && active) {
                joined = true;
                if (currentWorldX !== wx || currentWorldY !== wy) {
                    currentWorldX = wx; currentWorldY = wy;
                    resetLoadingTracker();
                }
                // If server corrected our predicted state, snap smoothly by updating _last
                // (Already handled via _last assignment above)
            }
            return;
        }
        if (tag === "BULLET") {
            // BULLET wx wy x y active [owner]
            if (parts.length < 6) return;
            const wx = parseInt(parts[1],10);
            const wy = parseInt(parts[2],10);
            const x = parseInt(parts[3],10);
            const y = parseInt(parts[4],10);
            const active = parseInt(parts[5],10);
            const owner = parts.length >= 7 ? parseInt(parts[6],10) : -1;
            // Reuse an existing bullet in same world that is nearest (<=1 tile) and not yet matched this batch
            let b = null;
            let bestDist = 3;
            for (let i = 0; i < bullets.length; i++) {
                const bb = bullets[i];
                if (bb.wx !== wx || bb.wy !== wy) continue;
                if (bb._seenBatch === currentBulletBatchId) continue;
                if (owner >= 0 && bb.owner === owner) { b = bb; break; }
                let d = Math.abs(bb.x - x) + Math.abs(bb.y - y);
                if (bb._last) {
                    const dl = Math.abs(bb._last.x - x) + Math.abs(bb._last.y - y);
                    if (dl < d) d = dl;
                }
                if (d <= 1 && d < bestDist) { b = bb; bestDist = d; }
            }
            if (!b) {
                b = { wx, wy, x, y, active, owner, _last: null, _lastUpdateTick: gameTick, _seenBatch: currentBulletBatchId };
                bullets.push(b);
            } else {
                b._last = { wx: b.wx, wy: b.wy, x: b.x, y: b.y };
                Object.assign(b, { wx, wy, x, y, active, owner });
                b._lastUpdateTick = gameTick;
                b._seenBatch = currentBulletBatchId;
            }
            // Mark as confirmed (no longer purely predicted)
            if (b.predicted) { b.predicted = false; }
            return;
        }
        if (tag === "ENEMY") {
            // ENEMY wx wy x y hp
            if (parts.length < 6) return;
            const [wx, wy, x, y, hp] = parseInts(parts, 1);
            enemies.push({ wx, wy, x, y, hp });
            return;
        }
        if (tag === "ENTR") {
            // ENTR wx wy bl br bu bd (1 blocked, 0 open)
            if (parts.length < 8) return;
            const wx = parseInt(parts[1], 10);
            const wy = parseInt(parts[2], 10);
            const bl = parseInt(parts[3], 10);
            const br = parseInt(parts[4], 10);
            const bu = parseInt(parts[5], 10);
            const bd = parseInt(parts[6], 10);
            if (wy>=0 && wy<WORLD_H && wx>=0 && wx<WORLD_W) {
                const midX = Math.floor(MAP_WIDTH/2), midY = Math.floor(MAP_HEIGHT/2);
                // Left entrance at (0, midY)
                if (wx > 0) { if (bl === 1) worldTiles[wy][wx][midY][0] = ':'; else if (worldTiles[wy][wx][midY][0] === ':') worldTiles[wy][wx][midY][0] = '.'; }
                // Right entrance at (MAP_WIDTH-1, midY)
                if (wx < WORLD_W - 1) { if (br === 1) worldTiles[wy][wx][midY][MAP_WIDTH-1] = ':'; else if (worldTiles[wy][wx][midY][MAP_WIDTH-1] === ':') worldTiles[wy][wx][midY][MAP_WIDTH-1] = '.'; }
                // Up entrance at (midX, 0)
                if (wy > 0) { if (bu === 1) worldTiles[wy][wx][0][midX] = ':'; else if (worldTiles[wy][wx][0][midX] === ':') worldTiles[wy][wx][0][midX] = '.'; }
                // Down entrance at (midX, MAP_HEIGHT-1)
                if (wy < WORLD_H - 1) { if (bd === 1) worldTiles[wy][wx][MAP_HEIGHT-1][midX] = ':'; else if (worldTiles[wy][wx][MAP_HEIGHT-1][midX] === ':') worldTiles[wy][wx][MAP_HEIGHT-1][midX] = '.'; }
            }
            return;
        }
        if (tag === "TILE") {
            // TILE wx wy x y ch
            if (parts.length < 6) return;
            const wx = parseInt(parts[1], 10);
            const wy = parseInt(parts[2], 10);
            const x = parseInt(parts[3], 10);
            const y = parseInt(parts[4], 10);
            const chToken = parts.slice(5).join(' ');
            const ch = chToken.length ? chToken[0] : '.';
            if (wy>=0 && wy<WORLD_H && wx>=0 && wx<WORLD_W && y>=0 && y<MAP_HEIGHT && x>=0 && x<MAP_WIDTH) {
                worldTiles[wy][wx][y][x] = ch;
                // Count unique tiles received for current world tile to decide loaded
                if (wx === currentWorldX && wy === currentWorldY) {
                    if (!tileRecv) resetTileRecv();
                    if (!tileRecv[y][x]) { tileRecv[y][x] = true; tileRecvCount++; }
                    if (tileRecvCount >= MAP_WIDTH * MAP_HEIGHT) initialMapLoaded = true;
                }
            }
            return;
        }
        // Unknown lines are ignored
    }

    // Input handling → INPUT dx dy shoot
    const keyState = new Set();
    const touchState = { left: false, right: false, up: false, down: false, shoot: false };
    function computeInput() {
        let dx = 0, dy = 0, shoot = 0;
        const leftActive = keyState.has("ArrowLeft") || keyState.has("a") || keyState.has("A") || touchState.left;
        const rightActive = keyState.has("ArrowRight") || keyState.has("d") || keyState.has("D") || touchState.right;
        const upActive = keyState.has("ArrowUp") || keyState.has("w") || keyState.has("W") || touchState.up;
        const downActive = keyState.has("ArrowDown") || keyState.has("s") || keyState.has("S") || touchState.down;
        if (leftActive && !rightActive) dx = -1; else if (rightActive && !leftActive) dx = 1;
        if (upActive && !downActive) dy = -1; else if (downActive && !upActive) dy = 1;
        if (keyState.has(" ") || touchState.shoot) shoot = 1;
        return { dx, dy, shoot };
    }

    function inputChanged(a, b) {
        return a.dx !== b.dx || a.dy !== b.dy || a.shoot !== b.shoot;
    }

    function sendInputNow(inp) {
        sendLine(`INPUT ${inp.dx} ${inp.dy} ${inp.shoot}`);
        lastSentInput = inp;
        lastInputSentAt = performance.now();
    }

    function tryPredictLocal(inp) {
        if (!joined || youId < 0) return;
        const p = players[youId];
        if (!p || !p.active) return;
        const now = performance.now();
        // Update facing based on input
        if (inp.dx !== 0 || inp.dy !== 0) myFacing = { dx: inp.dx, dy: inp.dy };
        // Predict movement at most once per server tick
        if ((inp.dx !== 0 || inp.dy !== 0) && (now - lastPredictedMoveAt) >= MOVE_STEP_MS) {
            let wx = p.wx, wy = p.wy, x = p.x, y = p.y;
            let nx = x + inp.dx, ny = y + inp.dy;
            let nwx = wx, nwy = wy;
            // handle world crossings similar to server logic; require the exact entry cell in next map to be open
            if (nx < 0) { if (wx > 0 && worldTiles[wy][wx - 1][y] && worldTiles[wy][wx - 1][y][MAP_WIDTH - 1] !== '#') { nwx = wx - 1; nx = MAP_WIDTH - 1; ny = y; } else return; }
            else if (nx >= MAP_WIDTH) { if (wx < WORLD_W - 1 && worldTiles[wy][wx + 1][y] && worldTiles[wy][wx + 1][y][0] !== '#') { nwx = wx + 1; nx = 0; ny = y; } else return; }
            else if (ny < 0) { if (wy > 0 && worldTiles[wy - 1][wx][MAP_HEIGHT - 1] && worldTiles[wy - 1][wx][MAP_HEIGHT - 1][x] !== '#') { nwy = wy - 1; ny = MAP_HEIGHT - 1; nx = x; } else return; }
            else if (ny >= MAP_HEIGHT) { if (wy < WORLD_H - 1 && worldTiles[wy + 1][wx][0] && worldTiles[wy + 1][wx][0][x] !== '#') { nwy = wy + 1; ny = 0; nx = x; } else return; }
            // If staying in map, ensure target not blocked
            const inSame = (nwx === wx && nwy === wy);
            if (inSame) {
                if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
                    if (worldTiles[wy][wx][ny][nx] === '#') return; // wall
                    // avoid stepping onto another active player
                    for (let i = 0; i < players.length; i++) {
                        if (i === youId) continue; const op = players[i];
                        if (!op || !op.active) continue; if (op.wx === wx && op.wy === wy && op.x === nx && op.y === ny) return;
                    }
                } else { return; }
            }
            // Apply predicted move
            p._last = { wx: p.wx, wy: p.wy, x: p.x, y: p.y };
            p.wx = nwx; p.wy = nwy; p.x = nx; p.y = ny; p._lastUpdateTick = gameTick;
            // If we crossed maps, refresh loading trackers for new map tiles
            if (nwx !== wx || nwy !== wy) { currentWorldX = nwx; currentWorldY = nwy; resetLoadingTracker(); }
            lastPredictedMoveAt = now;
        }
        // Predict shooting on press (or rate-limited while super)
        const shootPressed = (inp.shoot && !prevShootState) || (inp.shoot && p.superTicks > 0 && (performance.now() - lastLocalShotAt) > 100);
        if (shootPressed) {
            const canShoot = (p.superTicks > 0) || ((performance.now() - lastLocalShotAt) >= SHOOT_COOLDOWN_MS);
            if (canShoot) {
                // spawn predicted bullet at our current position moving in facing
                const dir = myFacing;
                const bx = p.x, by = p.y;
                const b = { wx: p.wx, wy: p.wy, x: bx, y: by, active: 1, _last: null, _lastUpdateTick: gameTick, _seenBatch: currentBulletBatchId, predicted: true, predictedAt: performance.now() };
                bullets.push(b);
                lastLocalShotAt = performance.now();
            }
        }
        prevShootState = inp.shoot;
    }

    // Server-driven pacing: send inputs on a fixed cadence and ping at 1 Hz
    const INPUT_INTERVAL_MS = 50; // align with server tick
    function startNetworkTimers() {
        stopNetworkTimers();
        pingTimer = setInterval(() => {
            if (!socket || socket.readyState !== 1) return;
            const token = String(Date.now());
            pingOutstanding[token] = performance.now();
            sendLine(`PING ${token}`);
            lastPingAt = performance.now();
        }, 1000);
        inputTimer = setInterval(() => {
            if (!socket || socket.readyState !== 1) return;
            const inp = computeInput();
            // Immediate send on change; otherwise periodic keep-alive for held keys
            const now = performance.now();
            if (inputChanged(inp, lastSentInput) || (now - lastInputSentAt) >= INPUT_INTERVAL_MS) {
                sendInputNow(inp);
            }
            tryPredictLocal(inp);
        }, INPUT_INTERVAL_MS);
    }
    function stopNetworkTimers() {
        if (pingTimer) { clearInterval(pingTimer); pingTimer = null; }
        if (inputTimer) { clearInterval(inputTimer); inputTimer = null; }
        for (const k in pingOutstanding) delete pingOutstanding[k];
        lastPingAt = 0; pingMs = -1;
    }

    // Time-based smoothing instead of pure tick offsets for better 60 FPS visuals
    const TICK_MS = 50; // server tick ~50ms
    const REMOTE_INTERP_TICKS = 3; // slightly quicker interpolation for snappier feel at 60 FPS
    const REMOTE_EXTRAP_TICKS = 12; // tighten extrapolation window to reduce overshoot

    // Simple rendering of one map: choose the map containing you, else center (4,4)
    function draw() {
        ctx.fillStyle = "#0e141f";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const me = (youId >= 0 && players[youId] && players[youId].active) ? players[youId] : null;
        const wx = me ? clamp(players[youId].wx, 0, WORLD_W - 1) : 4;
        const wy = me ? clamp(players[youId].wy, 0, WORLD_H - 1) : 4;

        // Use monospace glyph rendering to match console visuals
        ctx.font = `${TILE_SIZE - 2}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
        ctx.textBaseline = "top";
        // If not yet loaded, draw animated loading overlay but keep entities visible underneath
        if (isLoadingActive()) {
            // draw entities faintly to orient the player while map loads
            ctx.globalAlpha = 0.35;
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const ch = worldTiles[wy][wx][y][x];
                    const px = x * TILE_SIZE; const py = y * TILE_SIZE;
                    let glyph = (ch === '#') ? '#' : (ch === 'X') ? 'X' : (ch === 'W') ? 'W' : '.';
                    let color = (ch === '#') ? "#ffffff" : (ch === 'X') ? "#facc15" : (ch === 'W') ? "#d946ef" : "#6b7280";
                    ctx.fillStyle = color; ctx.fillText(glyph, px + 1, py + 1);
                }
            }
            // entities overlay
            for (const e of enemies) { if (e.wx===wx && e.wy===wy) { ctx.fillStyle = "#ef4444"; ctx.fillText('E', e.x*TILE_SIZE+1, e.y*TILE_SIZE+1); } }
            for (const b of bullets) { if (b.active && b.wx===wx && b.wy===wy) { ctx.fillStyle = "#22c55e"; ctx.fillText('*', b.x*TILE_SIZE+1, b.y*TILE_SIZE+1); } }
            for (let i=0;i<players.length;i++){ const p=players[i]; if(p&&p.active&&p.wx===wx&&p.wy===wy){ ctx.fillStyle=colorFromIndex(p.color); ctx.fillText('@', p.x*TILE_SIZE+1, p.y*TILE_SIZE+1);} }
            ctx.globalAlpha = 1.0;
            // loading overlay on top
            drawLoading();
            return;
        }
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                const ch = worldTiles[wy][wx][y][x];
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                let glyph = ' ';
                let color = "#aab1c2"; // bright black / gray
                if (ch === '#') { glyph = '#'; color = "#ffffff"; }
                else if (ch === '.') { glyph = '.'; color = "#6b7280"; }
                else if (ch === ':') { glyph = '.'; color = "#ffffff"; }
                else if (ch === 'M') { glyph = 'M'; color = "#22c55e"; }
                else if (ch === 'X') { glyph = 'X'; color = "#facc15"; }
                else if (ch === 'W') { glyph = 'W'; color = "#d946ef"; }
                else if (ch === '@') { glyph = '.'; color = "#6b7280"; }
                ctx.fillStyle = color;
                ctx.fillText(glyph, px + 1, py + 1);
            }
        }

        // Draw enemies in this map (glyph 'E', bright red)
        for (const e of enemies) {
            if (e.wx !== wx || e.wy !== wy) continue;
            const px = e.x * TILE_SIZE;
            const py = e.y * TILE_SIZE;
            // Hide enemies inside bushes
            if (worldTiles[wy][wx][e.y] && worldTiles[wy][wx][e.y][e.x] === 'M') continue;
            ctx.fillStyle = "#ef4444";
            ctx.fillText('E', px + 1, py + 1);
        }

        // Draw bullets with time-based interpolation/extrapolation
        for (const b of bullets) {
            if (!b.active || b.wx !== wx || b.wy !== wy) continue;
            let bx = b.x, by = b.y;
            if (b._last) {
                const ticks = gameTick - (b._lastUpdateTick || gameTick);
                const sameWorld = (b._last.wx === b.wx && b._last.wy === b.wy);
                if (sameWorld) {
                    const lx = b._last.x, ly = b._last.y;
                    const mdx = bx - lx, mdy = by - ly;
                    if (ticks > 0 && ticks < REMOTE_INTERP_TICKS) {
                        if (lx !== bx || ly !== by) {
                            let sx = lx, sy = ly;
                            if (bx > lx) sx = lx + 1; else if (bx < lx) sx = lx - 1;
                            if (by > ly) sy = ly + 1; else if (by < ly) sy = ly - 1;
                            bx = sx; by = sy;
                        }
                    } else if (ticks >= REMOTE_INTERP_TICKS && ticks < REMOTE_EXTRAP_TICKS) {
                        // Do not extrapolate local player's bullets to avoid behind-spawn artifacts
                        if (b.owner === youId) {
                            bx = bx; by = by;
                        } else {
                        const sdx = mdx > 0 ? 1 : (mdx < 0 ? -1 : 0);
                        const sdy = mdy > 0 ? 1 : (mdy < 0 ? -1 : 0);
                        const nx = clamp(bx + sdx, 0, MAP_WIDTH - 1);
                        const ny = clamp(by + sdy, 0, MAP_HEIGHT - 1);
                        const nextTile = worldTiles[wy][wx][ny][nx];
                        if (nextTile !== '#') { bx = nx; by = ny; }
                        }
                    }
                }
            }
            const px = bx * TILE_SIZE;
            const py = by * TILE_SIZE;
            ctx.fillStyle = "#22c55e";
            ctx.fillText('*', px + 1, py + 1);
        }

        // Draw players with time-based interpolation/extrapolation
        for (let i = 0; i < players.length; i++) {
            const p = players[i];
            if (!p || !p.active || p.wx !== wx || p.wy !== wy) continue;
            let rx = p.x, ry = p.y;
            if (p._last) {
                const ticks = gameTick - (p._lastUpdateTick || gameTick);
                const sameWorld = (p._last.wx === p.wx && p._last.wy === p.wy);
                if (sameWorld) {
                    const lx = p._last.x, ly = p._last.y;
                    const mdx = rx - lx, mdy = ry - ly;
                    if (ticks > 0 && ticks < REMOTE_INTERP_TICKS) {
                        if (lx !== rx || ly !== ry) {
                            let sx = lx, sy = ly;
                            if (rx > lx) sx = lx + 1; else if (rx < lx) sx = lx - 1;
                            if (ry > ly) sy = ly + 1; else if (ry < ly) sy = ly - 1;
                            rx = sx; ry = sy;
                        }
                    } else if (ticks >= REMOTE_INTERP_TICKS && ticks < REMOTE_EXTRAP_TICKS) {
                        // Don't extrapolate the local player; it causes snap-back after key release
                        if (i !== youId) {
                        const sdx = mdx > 0 ? 1 : (mdx < 0 ? -1 : 0);
                        const sdy = mdy > 0 ? 1 : (mdy < 0 ? -1 : 0);
                        rx = clamp(rx + sdx, 0, MAP_WIDTH - 1);
                        ry = clamp(ry + sdy, 0, MAP_HEIGHT - 1);
                        }
                    }
                }
            }
            const px = rx * TILE_SIZE;
            const py = ry * TILE_SIZE;
            const isYou = (i === youId);
            const flicker = p.invincibleTicks > 0 && ((p.invincibleTicks >> 3) & 1);
            if (flicker && isYou) continue;
            // Hide remote players when standing on a bush tile ('M')
            const under = worldTiles[wy][wx][ry] && worldTiles[wy][wx][ry][rx];
            if (under === 'M') continue;
            ctx.fillStyle = colorFromIndex(p.color);
            ctx.fillText('@', px + 1, py + 1);
        }

        // HUD: HP and Ping (show loading hint while preparing)
        const hudY = MAP_HEIGHT * TILE_SIZE + 4;
        ctx.fillStyle = "#dbe2f1";
        const hpText = (!me || !initialMapLoaded) ? "Loading..." : ("HP: " + me.hp);
        const pingText = "Ping: " + (pingMs >= 0 ? (pingMs + " ms") : "-- ms");
        ctx.fillText(hpText + "   " + pingText, 8, hudY);

        // Titles and layout
        const titleY = hudY + TILE_SIZE;
        const leftX = 8;
        const charW = ctx.measureText('M').width;
        const cols = 4, rows = 4, cellWChars = 7, gapChars = 4;
        const scoreboardWidthPx = cols * cellWChars * charW + gapChars * charW;
        const rightX = leftX + scoreboardWidthPx;
        ctx.fillText("Scoreboard", leftX, titleY);
        ctx.fillText("Minimap", rightX, titleY);
        if (!me || isLoadingActive()) {
            ctx.fillStyle = "#9fb2d6";
            ctx.fillText("Loading starting map...", leftX, titleY - TILE_SIZE + 2);
        }

        // Scoreboard (4x4)
        for (let r = 0; r < rows; r++) {
            const y = titleY + TILE_SIZE + r * (TILE_SIZE - 2);
            for (let c = 0; c < cols; c++) {
                const idx = r * cols + c;
                const x = leftX + c * (cellWChars * charW);
                const p = players[idx];
                if (p && p.active) {
                    ctx.fillStyle = colorFromIndex(p.color);
                    ctx.fillText('@', x, y);
                    ctx.fillStyle = "#dbe2f1";
                    const scoreStr = String(p.score ?? 0).padStart(4, ' ');
                    ctx.fillText(scoreStr, x + charW * 2, y);
                } else {
                    ctx.fillStyle = "#5b6478";
                    ctx.fillText(' ', x, y);
                }
            }
        }

        // Minimap (9x9)
        const miniTopY = titleY + TILE_SIZE;
        for (let my = 0; my < WORLD_H; my++) {
            const y = miniTopY + my * (TILE_SIZE - 2);
            for (let mx = 0; mx < WORLD_W; mx++) {
                let ch = '.';
                let col = "#8b93a6";
                const isCur = (mx === wx && my === wy);
                if (isCur) { ch = 'X'; col = "#ffffff"; }
                let playerColor = null;
                for (let i = 0; i < players.length; i++) {
                    const p = players[i];
                    if (!p || !p.active) continue;
                    if (p.wx === mx && p.wy === my) { playerColor = colorFromIndex(p.color); break; }
                }
                if (!isCur && playerColor) { ch = '@'; col = playerColor; }
                ctx.fillStyle = col;
                const x = rightX + (mx * charW);
                ctx.fillText(ch, x, y);
            }
        }
    }

    function colorFromIndex(idx) {
        // Match console mapping for first 6: blue, magenta, cyan, green, yellow, red
        const palette = [
            "#60a5fa", // bright blue
            "#d946ef", // bright magenta
            "#22d3ee", // bright cyan
            "#22c55e", // bright green
            "#facc15", // bright yellow
            "#ef4444", // bright red
            // Fallback extended colors (not used by console mapping but kept for safety)
            "#f97316", "#38bdf8", "#f472b6", "#86efac", "#94a3b8", "#fca5a5", "#e5e7eb", "#14b8a6"
        ];
        return palette[Math.abs(idx) % palette.length];
    }

    // Loading screen similar to console: dim dots, sparkles, LOADING text
    function drawLoading() {
        // Animated dots background
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                ctx.fillStyle = "#6b7280";
                ctx.fillText('.', px + 1, py + 1);
            }
        }
        // Sparkles: deterministic per tick without using performance.now heavy
        const tick = loadingAnimTick++;
        const sparkCount = 30;
        for (let i = 0; i < sparkCount; i++) {
            const seed = (tick * 1103515245 + 12345 + i * 2654435761) >>> 0;
            const sx = seed % MAP_WIDTH;
            const sy = (seed >>> 8) % MAP_HEIGHT;
            const px = sx * TILE_SIZE;
            const py = sy * TILE_SIZE;
            ctx.fillStyle = "#facc15";
            ctx.fillText('*', px + 1, py + 1);
        }
        // Center LOADING text
        const text = "LOADING";
        const charW = ctx.measureText('M').width;
        const cx = Math.floor((MAP_WIDTH - text.length) / 2) * charW + 1;
        const cy = Math.floor(MAP_HEIGHT / 2) * TILE_SIZE + 1;
        ctx.fillStyle = "#ffffff";
        ctx.fillText(text, cx, cy);
    }

    // Main loop
    function loop(ts) {
        // Advance a client-side tick counter to drive smoothing timing
        gameTick = (gameTick + 1) | 0;
        if (netDirty) { netDirty = false; }
        draw();
        requestAnimationFrame(loop);
    }

    // Keyboard events
    window.addEventListener("keydown", (e) => {
        if (e.key === "q" || e.key === "Q") { disconnect(); return; }
        if (e.key === " ") e.preventDefault();
        keyState.add(e.key);
        const inp = computeInput();
        if (!socket || socket.readyState !== 1) return;
        if (inputChanged(inp, lastSentInput)) {
            sendInputNow(inp);
            tryPredictLocal(inp);
        }
    });
    window.addEventListener("keyup", (e) => { keyState.delete(e.key); const inp = computeInput(); if (socket && socket.readyState === 1) { if (inputChanged(inp, lastSentInput)) { sendInputNow(inp); tryPredictLocal(inp); } } });

    btnConnect.addEventListener("click", () => { connectAbort = false; connect(); });
    btnDisconnect.addEventListener("click", disconnect);

    // Mobile detection and touch controls setup
    function isMobileClient() {
        try { if (window.matchMedia) { if (matchMedia("(pointer: coarse)").matches) return true; if (matchMedia("(hover: none)").matches) return true; } } catch {}
        return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    }
    function bindButton(el, onDown, onUp) {
        if (!el) return;
        const down = (e) => { e.preventDefault(); onDown(); el.classList.add("active"); };
        const up = (e) => { e.preventDefault(); onUp(); el.classList.remove("active"); };
        if (window.PointerEvent) {
            el.addEventListener("pointerdown", down, { passive: false });
            el.addEventListener("pointerup", up, { passive: false });
            el.addEventListener("pointercancel", up, { passive: false });
            el.addEventListener("pointerleave", up, { passive: false });
        } else {
            el.addEventListener("touchstart", down, { passive: false });
            el.addEventListener("touchend", up, { passive: false });
            el.addEventListener("touchcancel", up, { passive: false });
            el.addEventListener("mousedown", down);
            el.addEventListener("mouseup", up);
            el.addEventListener("mouseleave", up);
        }
    }
    function setupTouchControls() {
        if (!touchControlsEl) return;
        touchControlsEl.style.display = "block";
        document.body.classList.add("is-mobile");
        bindButton(btnLeft, () => { touchState.left = true; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} }, () => { touchState.left = false; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} });
        bindButton(btnRight, () => { touchState.right = true; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} }, () => { touchState.right = false; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} });
        bindButton(btnUp, () => { touchState.up = true; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} }, () => { touchState.up = false; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} });
        bindButton(btnDown, () => { touchState.down = true; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} }, () => { touchState.down = false; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} });
        bindButton(btnShoot, () => { touchState.shoot = true; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} }, () => { touchState.shoot = false; const inp = computeInput(); if (socket && socket.readyState===1){ sendInputNow(inp); tryPredictLocal(inp);} });
    }
    if (isMobileClient()) { setupTouchControls(); }

    // Start
    requestAnimationFrame(loop);
    // Auto-connect on load to default
    serverUrlInput.value = DEFAULT_ENDPOINT;
    connect();
})();
</script>
</body>
</html>


