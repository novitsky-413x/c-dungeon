<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dungeon Web Client</title>
    <style>
        html, body { height: 100%; margin: 0; background: #0b0e13; color: #dbe2f1; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .wrap { display: flex; flex-direction: column; gap: 8px; padding: 12px; max-width: 920px; margin: 0 auto; }
        .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        input, button, select { background: #121722; color: #e8eefc; border: 1px solid #2b3342; border-radius: 6px; padding: 8px 10px; font: inherit; }
        button { cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .status { font-size: 12px; opacity: 0.8; }
        canvas { background: #0e141f; border: 1px solid #2b3342; border-radius: 6px; image-rendering: pixelated; }
        .hint { font-size: 12px; color: #9fb2d6; }
        .row > * { flex: 0 0 auto; }
        .spacer { flex: 1 1 auto; }
    </style>
</head>
<body>
<div class="wrap">
    <div class="row">
        <input id="serverUrl" type="text" placeholder="wss://host[:port]/path" value="wss://runcode.at/ws" style="min-width:320px" />
        <button id="connect">Connect</button>
        <button id="disconnect" disabled>Disconnect</button>
        <div class="spacer"></div>
        <div id="status" class="status">Idle</div>
    </div>
    <canvas id="view" width="800" height="480"></canvas>
    <div class="hint">Controls: WASD/Arrows to move, Space to shoot, Q to quit. Focus the page to control.</div>
</div>

<script>
(() => {
    "use strict";

    // Constants aligned with C/types.h
    const MAP_WIDTH = 40;
    const MAP_HEIGHT = 18;
    const WORLD_W = 9;
    const WORLD_H = 9;
    const TILE_SIZE = 16; // pixels per tile in canvas
    const VIEW_TILE_W = MAP_WIDTH;
    const VIEW_TILE_H = MAP_HEIGHT + 14; // extra HUD rows for HUD + scoreboard + minimap
    const CANVAS_W = VIEW_TILE_W * TILE_SIZE;
    const CANVAS_H = VIEW_TILE_H * TILE_SIZE;

    const canvas = document.getElementById("view");
    const ctx = canvas.getContext("2d");
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;

    const statusEl = document.getElementById("status");
    const btnConnect = document.getElementById("connect");
    const btnDisconnect = document.getElementById("disconnect");
    const serverUrlInput = document.getElementById("serverUrl");

    let socket = null;
    let youId = -1;
    let lastPingAt = 0;
    let pingMs = -1;
    const pingOutstanding = Object.create(null);
    let recvBuf = "";
    let pingTimer = null;
    let inputTimer = null;
    // Track whether the current map (world tile) is fully received
    let initialMapLoaded = false;
    let loadingAnimTick = 0;
    let currentWorldX = -1, currentWorldY = -1;
    let joined = false; // becomes true after we receive our PLAYER line with active=1

    // World state
    const worldTiles = new Array(WORLD_H);
    for (let y = 0; y < WORLD_H; y++) {
        worldTiles[y] = new Array(WORLD_W);
        for (let x = 0; x < WORLD_W; x++) {
            worldTiles[y][x] = new Array(MAP_HEIGHT);
            for (let my = 0; my < MAP_HEIGHT; my++) {
                worldTiles[y][x][my] = new Array(MAP_WIDTH).fill('.');
            }
        }
    }

    const players = []; // index by id: {active, wx, wy, x, y, color, hp, invincibleTicks, superTicks, score}
    const bullets = []; // array of {wx, wy, x, y, active}
    const enemies = []; // array of {wx, wy, x, y, hp}

    function setStatus(text) { statusEl.textContent = text; }

    // Default endpoint; can be overridden via input
    const DEFAULT_ENDPOINT = "wss://runcode.at/ws";

    let connectAbort = false;
    async function connect() {
        btnConnect.disabled = true;
        btnDisconnect.disabled = true;
        recvBuf = "";
        youId = -1;
        joined = false;
        currentWorldX = -1; currentWorldY = -1; initialMapLoaded = false; loadingAnimTick = 0;
        connectAbort = false;

        const target = (serverUrlInput.value && serverUrlInput.value.trim()) ? serverUrlInput.value.trim() : DEFAULT_ENDPOINT;
        const ok = await tryOneEndpoint(target);
        if (!ok) {
            setStatus("Unable to connect to " + target + ". Check server.");
            btnConnect.disabled = false;
        }
    }

    function tryOneEndpoint(url) {
        return new Promise((resolve) => {
            let opened = false;
            setStatus("Connecting: " + url);
            let ws;
            try {
                ws = new WebSocket(url);
            } catch (e) {
                setStatus("WebSocket error constructing: " + e);
                resolve(false);
                return;
            }
            ws.binaryType = "arraybuffer";
            ws.onopen = () => {
                if (connectAbort) { try { ws.close(); } catch {} resolve(false); return; }
                opened = true;
                socket = ws;
                setStatus("Connected: " + url + " (HELLO)");
                sendLine("HELLO");
                startNetworkTimers();
                btnDisconnect.disabled = false;
                resolve(true);
            };
            ws.onmessage = (ev) => {
                const handleText = (text) => {
                    // Each server tick arrives as one WS message containing a batch of lines.
                    // Clear transient arrays so we render only the latest authoritative tick.
                    bullets.length = 0;
                    enemies.length = 0;
                    recvBuf += text;
                    processBuffer();
                    draw();
                };
                if (typeof ev.data === "string") {
                    handleText(ev.data);
                } else if (ev.data instanceof Blob) {
                    ev.data.text().then(handleText).catch(() => {});
                } else if (ev.data instanceof ArrayBuffer) {
                    try { handleText(new TextDecoder().decode(ev.data)); } catch {}
                } else {
                    // Fallback: try toString
                    try { handleText(String(ev.data || "")); } catch {}
                }
            };
            ws.onerror = () => {
                if (!opened) setStatus("Failed: " + url);
            };
            ws.onclose = () => {
                if (socket === ws) {
                    setStatus("Disconnected");
                    btnConnect.disabled = false;
                    btnDisconnect.disabled = true;
                    socket = null;
                    stopNetworkTimers();
                }
                if (!opened) resolve(false); // try next endpoint
            };
        });
    }

    function disconnect() {
        if (socket) {
            try { sendLine("BYE"); } catch {}
            socket.close();
        }
    }

    function sendLine(s) {
        if (!socket || socket.readyState !== 1) return;
        socket.send(s + "\n");
    }

    function clamp(val, lo, hi) { return Math.max(lo, Math.min(hi, val)); }

    function processBuffer() {
        while (true) {
            const idx = recvBuf.indexOf("\n");
            if (idx < 0) break;
            const line = recvBuf.slice(0, idx);
            recvBuf = recvBuf.slice(idx + 1);
            handleLine(line.trim());
        }
    }

    function ensurePlayersSize(id) {
        while (players.length <= id) players.push({active:0, wx:0, wy:0, x:0, y:0, color:0, hp:0, invincibleTicks:0, superTicks:0, score:0});
    }

    function parseInts(parts, startIndex) {
        const out = [];
        for (let i = startIndex; i < parts.length; i++) out.push(parseInt(parts[i], 10));
        return out;
    }

    function handleLine(line) {
        if (!line) return;
        const parts = line.split(/\s+/);
        const tag = parts[0];
        if (tag === "YOU") {
            if (parts.length >= 2) youId = parseInt(parts[1], 10);
            joined = true;
            setStatus(`Joined, you are id ${youId}`);
            return;
        }
        if (tag === "PONG") {
            if (parts.length >= 2) {
                const token = parts.slice(1).join(" ");
                const sentAt = pingOutstanding[token];
                if (sentAt) {
                    pingMs = Math.round(performance.now() - sentAt);
                    delete pingOutstanding[token];
                }
            }
            return;
        }
        if (tag === "FULL") { setStatus("Server full"); return; }
        if (tag === "PLAYER") {
            // PLAYER id wx wy x y color active hp invincibleTicks superTicks score
            if (parts.length < 12) return;
            const [id, wx, wy, x, y, color, active, hp, invTicks, superTicks, score] = parseInts(parts, 1);
            ensurePlayersSize(id);
            Object.assign(players[id], { wx, wy, x, y, color, active, hp, invincibleTicks: invTicks, superTicks, score });
            if (id === youId && active) {
                joined = true;
                if (currentWorldX !== wx || currentWorldY !== wy) {
                    currentWorldX = wx; currentWorldY = wy;
                    initialMapLoaded = false; loadingAnimTick = 0;
                }
            }
            return;
        }
        if (tag === "BULLET") {
            // BULLET wx wy x y active
            if (parts.length < 6) return;
            const [wx, wy, x, y, active] = parseInts(parts, 1);
            bullets.push({ wx, wy, x, y, active });
            return;
        }
        if (tag === "ENEMY") {
            // ENEMY wx wy x y hp
            if (parts.length < 6) return;
            const [wx, wy, x, y, hp] = parseInts(parts, 1);
            enemies.push({ wx, wy, x, y, hp });
            return;
        }
        if (tag === "TILE") {
            // TILE wx wy x y ch
            if (parts.length < 6) return;
            const wx = parseInt(parts[1], 10);
            const wy = parseInt(parts[2], 10);
            const x = parseInt(parts[3], 10);
            const y = parseInt(parts[4], 10);
            const chToken = parts.slice(5).join(' ');
            const ch = chToken.length ? chToken[0] : '.';
            if (wy>=0 && wy<WORLD_H && wx>=0 && wx<WORLD_W && y>=0 && y<MAP_HEIGHT && x>=0 && x<MAP_WIDTH) {
                worldTiles[wy][wx][y][x] = ch;
                // Mark map loaded when last tile of the current world tile arrives
                if (wx === currentWorldX && wy === currentWorldY) {
                    if (x === MAP_WIDTH - 1 && y === MAP_HEIGHT - 1) initialMapLoaded = true;
                }
            }
            return;
        }
        // Unknown lines are ignored
    }

    // Input handling → INPUT dx dy shoot
    const keyState = new Set();
    function computeInput() {
        let dx = 0, dy = 0, shoot = 0;
        if (keyState.has("ArrowLeft") || keyState.has("a") || keyState.has("A")) dx = -1;
        else if (keyState.has("ArrowRight") || keyState.has("d") || keyState.has("D")) dx = 1;
        if (keyState.has("ArrowUp") || keyState.has("w") || keyState.has("W")) dy = -1;
        else if (keyState.has("ArrowDown") || keyState.has("s") || keyState.has("S")) dy = 1;
        if (keyState.has(" ")) shoot = 1;
        return { dx, dy, shoot };
    }

    // Server-driven pacing: send inputs on a fixed cadence and ping at 1 Hz
    const INPUT_INTERVAL_MS = 100;
    function startNetworkTimers() {
        stopNetworkTimers();
        pingTimer = setInterval(() => {
            if (!socket || socket.readyState !== 1) return;
            const token = String(Date.now());
            pingOutstanding[token] = performance.now();
            sendLine(`PING ${token}`);
            lastPingAt = performance.now();
        }, 1000);
        inputTimer = setInterval(() => {
            if (!socket || socket.readyState !== 1) return;
            const { dx, dy, shoot } = computeInput();
            if (dx !== 0 || dy !== 0 || shoot !== 0) sendLine(`INPUT ${dx} ${dy} ${shoot}`);
        }, INPUT_INTERVAL_MS);
    }
    function stopNetworkTimers() {
        if (pingTimer) { clearInterval(pingTimer); pingTimer = null; }
        if (inputTimer) { clearInterval(inputTimer); inputTimer = null; }
        for (const k in pingOutstanding) delete pingOutstanding[k];
        lastPingAt = 0; pingMs = -1;
    }

    // Simple rendering of one map: choose the map containing you, else center (4,4)
    function draw() {
        ctx.fillStyle = "#0e141f";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const me = (youId >= 0 && players[youId] && players[youId].active) ? players[youId] : null;
        const wx = me ? clamp(players[youId].wx, 0, WORLD_W - 1) : 4;
        const wy = me ? clamp(players[youId].wy, 0, WORLD_H - 1) : 4;

        // Use monospace glyph rendering to match console visuals
        ctx.font = `${TILE_SIZE - 2}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
        ctx.textBaseline = "top";
        // If not yet loaded, draw animated loading overlay but keep entities visible underneath
        if (!initialMapLoaded) {
            // draw entities faintly to orient the player while map loads
            ctx.globalAlpha = 0.35;
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const ch = worldTiles[wy][wx][y][x];
                    const px = x * TILE_SIZE; const py = y * TILE_SIZE;
                    let glyph = (ch === '#') ? '#' : (ch === 'X') ? 'X' : (ch === 'W') ? 'W' : '.';
                    let color = (ch === '#') ? "#ffffff" : (ch === 'X') ? "#facc15" : (ch === 'W') ? "#d946ef" : "#6b7280";
                    ctx.fillStyle = color; ctx.fillText(glyph, px + 1, py + 1);
                }
            }
            // entities overlay
            for (const e of enemies) { if (e.wx===wx && e.wy===wy) { ctx.fillStyle = "#ef4444"; ctx.fillText('E', e.x*TILE_SIZE+1, e.y*TILE_SIZE+1); } }
            for (const b of bullets) { if (b.active && b.wx===wx && b.wy===wy) { ctx.fillStyle = "#22c55e"; ctx.fillText('*', b.x*TILE_SIZE+1, b.y*TILE_SIZE+1); } }
            for (let i=0;i<players.length;i++){ const p=players[i]; if(p&&p.active&&p.wx===wx&&p.wy===wy){ ctx.fillStyle=(i===youId)?"#22d3ee":colorFromIndex(p.color); ctx.fillText('@', p.x*TILE_SIZE+1, p.y*TILE_SIZE+1);} }
            ctx.globalAlpha = 1.0;
            // loading overlay on top
            drawLoading();
            return;
        }
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                const ch = worldTiles[wy][wx][y][x];
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                let glyph = ' ';
                let color = "#aab1c2"; // bright black / gray
                if (ch === '#') { glyph = '#'; color = "#ffffff"; }
                else if (ch === '.') { glyph = '.'; color = "#6b7280"; }
                else if (ch === 'X') { glyph = 'X'; color = "#facc15"; }
                else if (ch === 'W') { glyph = 'W'; color = "#d946ef"; }
                else if (ch === '@') { glyph = '.'; color = "#6b7280"; }
                ctx.fillStyle = color;
                ctx.fillText(glyph, px + 1, py + 1);
            }
        }

        // Draw enemies in this map (glyph 'E', bright red)
        for (const e of enemies) {
            if (e.wx !== wx || e.wy !== wy) continue;
            const px = e.x * TILE_SIZE;
            const py = e.y * TILE_SIZE;
            ctx.fillStyle = "#ef4444";
            ctx.fillText('E', px + 1, py + 1);
        }

        // Draw bullets in this map (glyph '*', bright green)
        for (const b of bullets) {
            if (!b.active || b.wx !== wx || b.wy !== wy) continue;
            const px = b.x * TILE_SIZE;
            const py = b.y * TILE_SIZE;
            ctx.fillStyle = "#22c55e";
            ctx.fillText('*', px + 1, py + 1);
        }

        // Draw players as '@'; you in bright cyan, others by color index
        for (let i = 0; i < players.length; i++) {
            const p = players[i];
            if (!p || !p.active || p.wx !== wx || p.wy !== wy) continue;
            const px = p.x * TILE_SIZE;
            const py = p.y * TILE_SIZE;
            const isYou = (i === youId);
            // Flicker during invincibility similar to console (~toggle every few ticks)
            const flicker = p.invincibleTicks > 0 && ((p.invincibleTicks >> 3) & 1);
            if (flicker && isYou) continue;
            ctx.fillStyle = isYou ? "#22d3ee" : colorFromIndex(p.color);
            ctx.fillText('@', px + 1, py + 1);
        }

        // HUD: HP and Ping (show loading hint while preparing)
        const hudY = MAP_HEIGHT * TILE_SIZE + 4;
        ctx.fillStyle = "#dbe2f1";
        const hpText = (!me || !initialMapLoaded) ? "Loading..." : ("HP: " + me.hp);
        const pingText = "Ping: " + (pingMs >= 0 ? (pingMs + " ms") : "-- ms");
        ctx.fillText(hpText + "   " + pingText, 8, hudY);

        // Titles and layout
        const titleY = hudY + TILE_SIZE;
        const leftX = 8;
        const charW = ctx.measureText('M').width;
        const cols = 4, rows = 4, cellWChars = 7, gapChars = 4;
        const scoreboardWidthPx = cols * cellWChars * charW + gapChars * charW;
        const rightX = leftX + scoreboardWidthPx;
        ctx.fillText("Scoreboard", leftX, titleY);
        ctx.fillText("Minimap", rightX, titleY);
        if (!me || !initialMapLoaded) {
            ctx.fillStyle = "#9fb2d6";
            ctx.fillText("Loading starting map...", leftX, titleY - TILE_SIZE + 2);
        }

        // Scoreboard (4x4)
        for (let r = 0; r < rows; r++) {
            const y = titleY + TILE_SIZE + r * (TILE_SIZE - 2);
            for (let c = 0; c < cols; c++) {
                const idx = r * cols + c;
                const x = leftX + c * (cellWChars * charW);
                const p = players[idx];
                if (p && p.active) {
                    ctx.fillStyle = colorFromIndex(p.color);
                    ctx.fillText('@', x, y);
                    ctx.fillStyle = "#dbe2f1";
                    const scoreStr = String(p.score ?? 0).padStart(4, ' ');
                    ctx.fillText(scoreStr, x + charW * 2, y);
                } else {
                    ctx.fillStyle = "#5b6478";
                    ctx.fillText(' ', x, y);
                }
            }
        }

        // Minimap (9x9)
        const miniTopY = titleY + TILE_SIZE;
        for (let my = 0; my < WORLD_H; my++) {
            const y = miniTopY + my * (TILE_SIZE - 2);
            for (let mx = 0; mx < WORLD_W; mx++) {
                let ch = '.';
                let col = "#8b93a6";
                const isCur = (mx === wx && my === wy);
                if (isCur) { ch = 'X'; col = "#ffffff"; }
                let playerColor = null;
                for (let i = 0; i < players.length; i++) {
                    const p = players[i];
                    if (!p || !p.active) continue;
                    if (p.wx === mx && p.wy === my) { playerColor = colorFromIndex(p.color); break; }
                }
                if (!isCur && playerColor) { ch = '@'; col = playerColor; }
                ctx.fillStyle = col;
                const x = rightX + (mx * charW);
                ctx.fillText(ch, x, y);
            }
        }
    }

    function colorFromIndex(idx) {
        // Approximate terminal bright ANSI palette for other players
        const palette = ["#22d3ee","#ef4444","#22c55e","#facc15","#d946ef","#14b8a6","#f97316","#60a5fa",
                         "#f472b6","#38bdf8","#fb7185","#94a3b8","#fca5a5","#e5e7eb","#86efac","#f8b4a0"]; // up to 16
        return palette[idx % palette.length];
    }

    // Loading screen similar to console: dim dots, sparkles, LOADING text
    function drawLoading() {
        // Animated dots background
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                ctx.fillStyle = "#6b7280";
                ctx.fillText('.', px + 1, py + 1);
            }
        }
        // Sparkles: deterministic per tick without using performance.now heavy
        const tick = loadingAnimTick++;
        const sparkCount = 30;
        for (let i = 0; i < sparkCount; i++) {
            const seed = (tick * 1103515245 + 12345 + i * 2654435761) >>> 0;
            const sx = seed % MAP_WIDTH;
            const sy = (seed >>> 8) % MAP_HEIGHT;
            const px = sx * TILE_SIZE;
            const py = sy * TILE_SIZE;
            ctx.fillStyle = "#facc15";
            ctx.fillText('*', px + 1, py + 1);
        }
        // Center LOADING text
        const text = "LOADING";
        const charW = ctx.measureText('M').width;
        const cx = Math.floor((MAP_WIDTH - text.length) / 2) * charW + 1;
        const cy = Math.floor(MAP_HEIGHT / 2) * TILE_SIZE + 1;
        ctx.fillStyle = "#ffffff";
        ctx.fillText(text, cx, cy);
    }

    // Main loop
    function loop(ts) {
        // Redraw continuously for HUD/minimap while all simulation is server-authoritative
        draw();
        requestAnimationFrame(loop);
    }

    // Keyboard events
    window.addEventListener("keydown", (e) => {
        if (e.key === "q" || e.key === "Q") { disconnect(); return; }
        if (e.key === " ") e.preventDefault();
        keyState.add(e.key);
    });
    window.addEventListener("keyup", (e) => { keyState.delete(e.key); });

    btnConnect.addEventListener("click", () => { connectAbort = false; connect(); });
    btnDisconnect.addEventListener("click", disconnect);

    // Start
    requestAnimationFrame(loop);
    // Auto-connect on load to default
    serverUrlInput.value = DEFAULT_ENDPOINT;
    connect();
})();
</script>
</body>
</html>


