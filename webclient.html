<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dungeon Web Client</title>
    <style>
        html, body { height: 100%; margin: 0; background: #0b0e13; color: #dbe2f1; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .wrap { display: flex; flex-direction: column; gap: 8px; padding: 12px; max-width: 920px; margin: 0 auto; }
        .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        input, button, select { background: #121722; color: #e8eefc; border: 1px solid #2b3342; border-radius: 6px; padding: 8px 10px; font: inherit; }
        button { cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .status { font-size: 12px; opacity: 0.8; }
        canvas { background: #0e141f; border: 1px solid #2b3342; border-radius: 6px; image-rendering: pixelated; }
        .hint { font-size: 12px; color: #9fb2d6; }
        .row > * { flex: 0 0 auto; }
        .spacer { flex: 1 1 auto; }
    </style>
</head>
<body>
<div class="wrap">
    <div class="row">
        <input id="serverUrl" type="text" placeholder="wss://host[:port]/path" value="wss://runcode.at/ws" style="min-width:320px" />
        <button id="connect">Connect</button>
        <button id="disconnect" disabled>Disconnect</button>
        <div class="spacer"></div>
        <div id="status" class="status">Idle</div>
    </div>
    <canvas id="view" width="800" height="480"></canvas>
    <div class="hint">Controls: WASD/Arrows to move, Space to shoot, Q to quit. Focus the page to control.</div>
</div>

<script>
(() => {
    "use strict";

    // Constants aligned with C/types.h
    const MAP_WIDTH = 40;
    const MAP_HEIGHT = 18;
    const WORLD_W = 9;
    const WORLD_H = 9;
    const TILE_SIZE = 16; // pixels per tile in canvas
    const VIEW_TILE_W = MAP_WIDTH;
    const VIEW_TILE_H = MAP_HEIGHT + 14; // extra HUD rows for HUD + scoreboard + minimap
    const CANVAS_W = VIEW_TILE_W * TILE_SIZE;
    const CANVAS_H = VIEW_TILE_H * TILE_SIZE;

    const canvas = document.getElementById("view");
    const ctx = canvas.getContext("2d");
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;

    const statusEl = document.getElementById("status");
    const btnConnect = document.getElementById("connect");
    const btnDisconnect = document.getElementById("disconnect");
    const serverUrlInput = document.getElementById("serverUrl");

    let socket = null;
    let youId = -1;
    let lastPingAt = 0;
    let pingMs = -1;
    const pingOutstanding = Object.create(null);
    let recvBuf = "";
    let pingTimer = null;
    let inputTimer = null;
    // Track whether the current map (world tile) is fully received
    let initialMapLoaded = false;
    const MIN_LOADING_MS = 500; // match console minimal loading duration
    let loadingStartAt = 0;
    let loadingAnimTick = 0;
    let currentWorldX = -1, currentWorldY = -1;
    let joined = false; // becomes true after we receive our PLAYER line with active=1
    // Client tick counter for interpolation/extrapolation; declared early to avoid TDZ in handlers
    let gameTick = 0;
    // Per-message marker to track which bullets were seen in the latest snapshot
    let currentBulletBatchId = 0;

    // World state
    const worldTiles = new Array(WORLD_H);
    for (let y = 0; y < WORLD_H; y++) {
        worldTiles[y] = new Array(WORLD_W);
        for (let x = 0; x < WORLD_W; x++) {
            worldTiles[y][x] = new Array(MAP_HEIGHT);
            for (let my = 0; my < MAP_HEIGHT; my++) {
                worldTiles[y][x][my] = new Array(MAP_WIDTH).fill('.');
            }
        }
    }

    const players = []; // index by id: {active, wx, wy, x, y, color, hp, invincibleTicks, superTicks, score, _last:{wx,wy,x,y}, _lastUpdateTick:number}
    const bullets = []; // array of {wx, wy, x, y, active, _last:{wx,wy,x,y}, _lastUpdateTick:number}
    const enemies = []; // array of {wx, wy, x, y, hp}

    // Track per-tile receipt for the current world tile to robustly detect full-load
    let tileRecv = null; // 2D array [MAP_HEIGHT][MAP_WIDTH] of booleans
    let tileRecvCount = 0;
    function resetTileRecv() {
        tileRecv = new Array(MAP_HEIGHT);
        for (let y = 0; y < MAP_HEIGHT; y++) {
            tileRecv[y] = new Array(MAP_WIDTH).fill(false);
        }
        tileRecvCount = 0;
    }
    function resetLoadingTracker() {
        // Trigger loading overlay only for the initial map. For subsequent
        // maps, keep the overlay disabled and only reset per-tile tracking.
        if (!initialMapLoaded) {
            initialMapLoaded = false;
            loadingAnimTick = 0;
            loadingStartAt = performance.now();
            resetTileRecv();
        } else {
            // Subsequent map transitions: no loading overlay
            resetTileRecv();
        }
    }
    function isLoadingActive() {
        if (!joined) return true;
        if (!initialMapLoaded) return true;
        if ((performance.now() - loadingStartAt) < MIN_LOADING_MS) return true;
        return false;
    }

    function setStatus(text) { statusEl.textContent = text; }

    // Default endpoint; can be overridden via input
    const DEFAULT_ENDPOINT = "wss://runcode.at/ws";

    let connectAbort = false;
    async function connect() {
        btnConnect.disabled = true;
        btnDisconnect.disabled = true;
        recvBuf = "";
        youId = -1;
        joined = false;
        currentWorldX = -1; currentWorldY = -1; resetLoadingTracker();
        connectAbort = false;

        const target = (serverUrlInput.value && serverUrlInput.value.trim()) ? serverUrlInput.value.trim() : DEFAULT_ENDPOINT;
        const ok = await tryOneEndpoint(target);
        if (!ok) {
            setStatus("Unable to connect to " + target + ". Check server.");
            btnConnect.disabled = false;
        }
    }

    function tryOneEndpoint(url) {
        return new Promise((resolve) => {
            let opened = false;
            setStatus("Connecting: " + url);
            let ws;
            try {
                ws = new WebSocket(url);
            } catch (e) {
                setStatus("WebSocket error constructing: " + e);
                resolve(false);
                return;
            }
            ws.binaryType = "arraybuffer";
            ws.onopen = () => {
                if (connectAbort) { try { ws.close(); } catch {} resolve(false); return; }
                opened = true;
                socket = ws;
                setStatus("Connected: " + url + " (HELLO)");
                sendLine("HELLO");
                startNetworkTimers();
                btnDisconnect.disabled = false;
                resolve(true);
            };
            ws.onmessage = (ev) => {
                const handleText = (text) => {
                    // Each server tick arrives as one WS message containing a batch of lines.
                    // For bullets, keep objects to enable smoothing; mark seen via batch id and deactivate unseen after apply.
                    currentBulletBatchId = (currentBulletBatchId + 1) | 0;
                    enemies.length = 0;
                    recvBuf += text;
                    processBuffer();
                    // Deactivate bullets not present in this snapshot
                    for (let i = 0; i < bullets.length; i++) {
                        const b = bullets[i];
                        if (b._seenBatch !== currentBulletBatchId) b.active = 0;
                    }
                    draw();
                };
                if (typeof ev.data === "string") {
                    handleText(ev.data);
                } else if (ev.data instanceof Blob) {
                    ev.data.text().then(handleText).catch(() => {});
                } else if (ev.data instanceof ArrayBuffer) {
                    try { handleText(new TextDecoder().decode(ev.data)); } catch {}
                } else {
                    // Fallback: try toString
                    try { handleText(String(ev.data || "")); } catch {}
                }
            };
            ws.onerror = () => {
                if (!opened) setStatus("Failed: " + url);
            };
            ws.onclose = () => {
                if (socket === ws) {
                    setStatus("Disconnected");
                    btnConnect.disabled = false;
                    btnDisconnect.disabled = true;
                    socket = null;
                    stopNetworkTimers();
                }
                if (!opened) resolve(false); // try next endpoint
            };
        });
    }

    function disconnect() {
        if (socket) {
            try { sendLine("BYE"); } catch {}
            socket.close();
        }
    }

    function sendLine(s) {
        if (!socket || socket.readyState !== 1) return;
        socket.send(s + "\n");
    }

    function clamp(val, lo, hi) { return Math.max(lo, Math.min(hi, val)); }

    function processBuffer() {
        while (true) {
            const idx = recvBuf.indexOf("\n");
            if (idx < 0) break;
            const line = recvBuf.slice(0, idx);
            recvBuf = recvBuf.slice(idx + 1);
            handleLine(line.trim());
        }
    }

    function ensurePlayersSize(id) {
        while (players.length <= id) players.push({active:0, wx:0, wy:0, x:0, y:0, color:0, hp:0, invincibleTicks:0, superTicks:0, score:0});
    }

    function parseInts(parts, startIndex) {
        const out = [];
        for (let i = startIndex; i < parts.length; i++) out.push(parseInt(parts[i], 10));
        return out;
    }

    function handleLine(line) {
        if (!line) return;
        const parts = line.split(/\s+/);
        const tag = parts[0];
        if (tag === "YOU") {
            if (parts.length >= 2) youId = parseInt(parts[1], 10);
            joined = true;
            if (!loadingStartAt) loadingStartAt = performance.now();
            setStatus(`Joined, you are id ${youId}`);
            return;
        }
        if (tag === "PONG") {
            if (parts.length >= 2) {
                const token = parts.slice(1).join(" ");
                const sentAt = pingOutstanding[token];
                if (sentAt) {
                    pingMs = Math.round(performance.now() - sentAt);
                    delete pingOutstanding[token];
                }
            }
            return;
        }
        if (tag === "FULL") { setStatus("Server full"); return; }
        if (tag === "PLAYER") {
            // PLAYER id wx wy x y color active hp invincibleTicks superTicks score
            if (parts.length < 12) return;
            const [id, wx, wy, x, y, color, active, hp, invTicks, superTicks, score] = parseInts(parts, 1);
            ensurePlayersSize(id);
            const p = players[id];
            const hadPrev = (p._lastUpdateTick !== undefined);
            if (hadPrev) p._last = { wx: p.wx, wy: p.wy, x: p.x, y: p.y };
            Object.assign(p, { wx, wy, x, y, color, active, hp, invincibleTicks: invTicks, superTicks, score });
            p._lastUpdateTick = gameTick;
            if (id === youId && active) {
                joined = true;
                if (currentWorldX !== wx || currentWorldY !== wy) {
                    currentWorldX = wx; currentWorldY = wy;
                    resetLoadingTracker();
                }
            }
            return;
        }
        if (tag === "BULLET") {
            // BULLET wx wy x y active
            if (parts.length < 6) return;
            const [wx, wy, x, y, active] = parseInts(parts, 1);
            // Reuse an existing bullet in same world that is nearest (<=1 tile) and not yet matched this batch
            let b = null;
            let bestDist = 3;
            for (let i = 0; i < bullets.length; i++) {
                const bb = bullets[i];
                if (bb.wx !== wx || bb.wy !== wy) continue;
                if (bb._seenBatch === currentBulletBatchId) continue;
                let d = Math.abs(bb.x - x) + Math.abs(bb.y - y);
                if (bb._last) {
                    const dl = Math.abs(bb._last.x - x) + Math.abs(bb._last.y - y);
                    if (dl < d) d = dl;
                }
                if (d <= 1 && d < bestDist) { b = bb; bestDist = d; }
            }
            if (!b) {
                b = { wx, wy, x, y, active, _last: null, _lastUpdateTick: gameTick, _seenBatch: currentBulletBatchId };
                bullets.push(b);
            } else {
                b._last = { wx: b.wx, wy: b.wy, x: b.x, y: b.y };
                Object.assign(b, { wx, wy, x, y, active });
                b._lastUpdateTick = gameTick;
                b._seenBatch = currentBulletBatchId;
            }
            return;
        }
        if (tag === "ENEMY") {
            // ENEMY wx wy x y hp
            if (parts.length < 6) return;
            const [wx, wy, x, y, hp] = parseInts(parts, 1);
            enemies.push({ wx, wy, x, y, hp });
            return;
        }
        if (tag === "TILE") {
            // TILE wx wy x y ch
            if (parts.length < 6) return;
            const wx = parseInt(parts[1], 10);
            const wy = parseInt(parts[2], 10);
            const x = parseInt(parts[3], 10);
            const y = parseInt(parts[4], 10);
            const chToken = parts.slice(5).join(' ');
            const ch = chToken.length ? chToken[0] : '.';
            if (wy>=0 && wy<WORLD_H && wx>=0 && wx<WORLD_W && y>=0 && y<MAP_HEIGHT && x>=0 && x<MAP_WIDTH) {
                worldTiles[wy][wx][y][x] = ch;
                // Count unique tiles received for current world tile to decide loaded
                if (wx === currentWorldX && wy === currentWorldY) {
                    if (!tileRecv) resetTileRecv();
                    if (!tileRecv[y][x]) { tileRecv[y][x] = true; tileRecvCount++; }
                    if (tileRecvCount >= MAP_WIDTH * MAP_HEIGHT) initialMapLoaded = true;
                }
            }
            return;
        }
        // Unknown lines are ignored
    }

    // Input handling → INPUT dx dy shoot
    const keyState = new Set();
    function computeInput() {
        let dx = 0, dy = 0, shoot = 0;
        if (keyState.has("ArrowLeft") || keyState.has("a") || keyState.has("A")) dx = -1;
        else if (keyState.has("ArrowRight") || keyState.has("d") || keyState.has("D")) dx = 1;
        if (keyState.has("ArrowUp") || keyState.has("w") || keyState.has("W")) dy = -1;
        else if (keyState.has("ArrowDown") || keyState.has("s") || keyState.has("S")) dy = 1;
        if (keyState.has(" ")) shoot = 1;
        return { dx, dy, shoot };
    }

    // Server-driven pacing: send inputs on a fixed cadence and ping at 1 Hz
    const INPUT_INTERVAL_MS = 100;
    function startNetworkTimers() {
        stopNetworkTimers();
        pingTimer = setInterval(() => {
            if (!socket || socket.readyState !== 1) return;
            const token = String(Date.now());
            pingOutstanding[token] = performance.now();
            sendLine(`PING ${token}`);
            lastPingAt = performance.now();
        }, 1000);
        inputTimer = setInterval(() => {
            if (!socket || socket.readyState !== 1) return;
            const { dx, dy, shoot } = computeInput();
            if (dx !== 0 || dy !== 0 || shoot !== 0) sendLine(`INPUT ${dx} ${dy} ${shoot}`);
        }, INPUT_INTERVAL_MS);
    }
    function stopNetworkTimers() {
        if (pingTimer) { clearInterval(pingTimer); pingTimer = null; }
        if (inputTimer) { clearInterval(inputTimer); inputTimer = null; }
        for (const k in pingOutstanding) delete pingOutstanding[k];
        lastPingAt = 0; pingMs = -1;
    }

    // Timing for smoothing
    const REMOTE_INTERP_TICKS = 4;
    const REMOTE_EXTRAP_TICKS = 15;

    // Simple rendering of one map: choose the map containing you, else center (4,4)
    function draw() {
        ctx.fillStyle = "#0e141f";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const me = (youId >= 0 && players[youId] && players[youId].active) ? players[youId] : null;
        const wx = me ? clamp(players[youId].wx, 0, WORLD_W - 1) : 4;
        const wy = me ? clamp(players[youId].wy, 0, WORLD_H - 1) : 4;

        // Use monospace glyph rendering to match console visuals
        ctx.font = `${TILE_SIZE - 2}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
        ctx.textBaseline = "top";
        // If not yet loaded, draw animated loading overlay but keep entities visible underneath
        if (isLoadingActive()) {
            // draw entities faintly to orient the player while map loads
            ctx.globalAlpha = 0.35;
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const ch = worldTiles[wy][wx][y][x];
                    const px = x * TILE_SIZE; const py = y * TILE_SIZE;
                    let glyph = (ch === '#') ? '#' : (ch === 'X') ? 'X' : (ch === 'W') ? 'W' : '.';
                    let color = (ch === '#') ? "#ffffff" : (ch === 'X') ? "#facc15" : (ch === 'W') ? "#d946ef" : "#6b7280";
                    ctx.fillStyle = color; ctx.fillText(glyph, px + 1, py + 1);
                }
            }
            // entities overlay
            for (const e of enemies) { if (e.wx===wx && e.wy===wy) { ctx.fillStyle = "#ef4444"; ctx.fillText('E', e.x*TILE_SIZE+1, e.y*TILE_SIZE+1); } }
            for (const b of bullets) { if (b.active && b.wx===wx && b.wy===wy) { ctx.fillStyle = "#22c55e"; ctx.fillText('*', b.x*TILE_SIZE+1, b.y*TILE_SIZE+1); } }
            for (let i=0;i<players.length;i++){ const p=players[i]; if(p&&p.active&&p.wx===wx&&p.wy===wy){ ctx.fillStyle=colorFromIndex(p.color); ctx.fillText('@', p.x*TILE_SIZE+1, p.y*TILE_SIZE+1);} }
            ctx.globalAlpha = 1.0;
            // loading overlay on top
            drawLoading();
            return;
        }
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                const ch = worldTiles[wy][wx][y][x];
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                let glyph = ' ';
                let color = "#aab1c2"; // bright black / gray
                if (ch === '#') { glyph = '#'; color = "#ffffff"; }
                else if (ch === '.') { glyph = '.'; color = "#6b7280"; }
                else if (ch === 'X') { glyph = 'X'; color = "#facc15"; }
                else if (ch === 'W') { glyph = 'W'; color = "#d946ef"; }
                else if (ch === '@') { glyph = '.'; color = "#6b7280"; }
                ctx.fillStyle = color;
                ctx.fillText(glyph, px + 1, py + 1);
            }
        }

        // Draw enemies in this map (glyph 'E', bright red)
        for (const e of enemies) {
            if (e.wx !== wx || e.wy !== wy) continue;
            const px = e.x * TILE_SIZE;
            const py = e.y * TILE_SIZE;
            ctx.fillStyle = "#ef4444";
            ctx.fillText('E', px + 1, py + 1);
        }

        // Draw bullets with interpolation/extrapolation similar to console
        for (const b of bullets) {
            if (!b.active || b.wx !== wx || b.wy !== wy) continue;
            let bx = b.x, by = b.y;
            if (b._last) {
                const ticks = gameTick - (b._lastUpdateTick || gameTick);
                const sameWorld = (b._last.wx === b.wx && b._last.wy === b.wy);
                if (sameWorld) {
                    const lx = b._last.x, ly = b._last.y;
                    const mdx = bx - lx, mdy = by - ly;
                    if (ticks > 0 && ticks < REMOTE_INTERP_TICKS) {
                        if (lx !== bx || ly !== by) {
                            let sx = lx, sy = ly;
                            if (bx > lx) sx = lx + 1; else if (bx < lx) sx = lx - 1;
                            if (by > ly) sy = ly + 1; else if (by < ly) sy = ly - 1;
                            bx = sx; by = sy;
                        }
                    } else if (ticks >= REMOTE_INTERP_TICKS && ticks < REMOTE_EXTRAP_TICKS) {
                        const sdx = mdx > 0 ? 1 : (mdx < 0 ? -1 : 0);
                        const sdy = mdy > 0 ? 1 : (mdy < 0 ? -1 : 0);
                        const nx = clamp(bx + sdx, 0, MAP_WIDTH - 1);
                        const ny = clamp(by + sdy, 0, MAP_HEIGHT - 1);
                        const nextTile = worldTiles[wy][wx][ny][nx];
                        if (nextTile !== '#') { bx = nx; by = ny; }
                    }
                }
            }
            const px = bx * TILE_SIZE;
            const py = by * TILE_SIZE;
            ctx.fillStyle = "#22c55e";
            ctx.fillText('*', px + 1, py + 1);
        }

        // Draw players with interpolation/extrapolation similar to console
        for (let i = 0; i < players.length; i++) {
            const p = players[i];
            if (!p || !p.active || p.wx !== wx || p.wy !== wy) continue;
            let rx = p.x, ry = p.y;
            if (p._last) {
                const ticks = gameTick - (p._lastUpdateTick || gameTick);
                const sameWorld = (p._last.wx === p.wx && p._last.wy === p.wy);
                if (sameWorld) {
                    const lx = p._last.x, ly = p._last.y;
                    const mdx = rx - lx, mdy = ry - ly;
                    if (ticks > 0 && ticks < REMOTE_INTERP_TICKS) {
                        if (lx !== rx || ly !== ry) {
                            let sx = lx, sy = ly;
                            if (rx > lx) sx = lx + 1; else if (rx < lx) sx = lx - 1;
                            if (ry > ly) sy = ly + 1; else if (ry < ly) sy = ly - 1;
                            rx = sx; ry = sy;
                        }
                    } else if (ticks >= REMOTE_INTERP_TICKS && ticks < REMOTE_EXTRAP_TICKS) {
                        const sdx = mdx > 0 ? 1 : (mdx < 0 ? -1 : 0);
                        const sdy = mdy > 0 ? 1 : (mdy < 0 ? -1 : 0);
                        rx = clamp(rx + sdx, 0, MAP_WIDTH - 1);
                        ry = clamp(ry + sdy, 0, MAP_HEIGHT - 1);
                    }
                }
            }
            const px = rx * TILE_SIZE;
            const py = ry * TILE_SIZE;
            const isYou = (i === youId);
            const flicker = p.invincibleTicks > 0 && ((p.invincibleTicks >> 3) & 1);
            if (flicker && isYou) continue;
            ctx.fillStyle = colorFromIndex(p.color);
            ctx.fillText('@', px + 1, py + 1);
        }

        // HUD: HP and Ping (show loading hint while preparing)
        const hudY = MAP_HEIGHT * TILE_SIZE + 4;
        ctx.fillStyle = "#dbe2f1";
        const hpText = (!me || !initialMapLoaded) ? "Loading..." : ("HP: " + me.hp);
        const pingText = "Ping: " + (pingMs >= 0 ? (pingMs + " ms") : "-- ms");
        ctx.fillText(hpText + "   " + pingText, 8, hudY);

        // Titles and layout
        const titleY = hudY + TILE_SIZE;
        const leftX = 8;
        const charW = ctx.measureText('M').width;
        const cols = 4, rows = 4, cellWChars = 7, gapChars = 4;
        const scoreboardWidthPx = cols * cellWChars * charW + gapChars * charW;
        const rightX = leftX + scoreboardWidthPx;
        ctx.fillText("Scoreboard", leftX, titleY);
        ctx.fillText("Minimap", rightX, titleY);
        if (!me || isLoadingActive()) {
            ctx.fillStyle = "#9fb2d6";
            ctx.fillText("Loading starting map...", leftX, titleY - TILE_SIZE + 2);
        }

        // Scoreboard (4x4)
        for (let r = 0; r < rows; r++) {
            const y = titleY + TILE_SIZE + r * (TILE_SIZE - 2);
            for (let c = 0; c < cols; c++) {
                const idx = r * cols + c;
                const x = leftX + c * (cellWChars * charW);
                const p = players[idx];
                if (p && p.active) {
                    ctx.fillStyle = colorFromIndex(p.color);
                    ctx.fillText('@', x, y);
                    ctx.fillStyle = "#dbe2f1";
                    const scoreStr = String(p.score ?? 0).padStart(4, ' ');
                    ctx.fillText(scoreStr, x + charW * 2, y);
                } else {
                    ctx.fillStyle = "#5b6478";
                    ctx.fillText(' ', x, y);
                }
            }
        }

        // Minimap (9x9)
        const miniTopY = titleY + TILE_SIZE;
        for (let my = 0; my < WORLD_H; my++) {
            const y = miniTopY + my * (TILE_SIZE - 2);
            for (let mx = 0; mx < WORLD_W; mx++) {
                let ch = '.';
                let col = "#8b93a6";
                const isCur = (mx === wx && my === wy);
                if (isCur) { ch = 'X'; col = "#ffffff"; }
                let playerColor = null;
                for (let i = 0; i < players.length; i++) {
                    const p = players[i];
                    if (!p || !p.active) continue;
                    if (p.wx === mx && p.wy === my) { playerColor = colorFromIndex(p.color); break; }
                }
                if (!isCur && playerColor) { ch = '@'; col = playerColor; }
                ctx.fillStyle = col;
                const x = rightX + (mx * charW);
                ctx.fillText(ch, x, y);
            }
        }
    }

    function colorFromIndex(idx) {
        // Match console mapping for first 6: blue, magenta, cyan, green, yellow, red
        const palette = [
            "#60a5fa", // bright blue
            "#d946ef", // bright magenta
            "#22d3ee", // bright cyan
            "#22c55e", // bright green
            "#facc15", // bright yellow
            "#ef4444", // bright red
            // Fallback extended colors (not used by console mapping but kept for safety)
            "#f97316", "#38bdf8", "#f472b6", "#86efac", "#94a3b8", "#fca5a5", "#e5e7eb", "#14b8a6"
        ];
        return palette[Math.abs(idx) % palette.length];
    }

    // Loading screen similar to console: dim dots, sparkles, LOADING text
    function drawLoading() {
        // Animated dots background
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                ctx.fillStyle = "#6b7280";
                ctx.fillText('.', px + 1, py + 1);
            }
        }
        // Sparkles: deterministic per tick without using performance.now heavy
        const tick = loadingAnimTick++;
        const sparkCount = 30;
        for (let i = 0; i < sparkCount; i++) {
            const seed = (tick * 1103515245 + 12345 + i * 2654435761) >>> 0;
            const sx = seed % MAP_WIDTH;
            const sy = (seed >>> 8) % MAP_HEIGHT;
            const px = sx * TILE_SIZE;
            const py = sy * TILE_SIZE;
            ctx.fillStyle = "#facc15";
            ctx.fillText('*', px + 1, py + 1);
        }
        // Center LOADING text
        const text = "LOADING";
        const charW = ctx.measureText('M').width;
        const cx = Math.floor((MAP_WIDTH - text.length) / 2) * charW + 1;
        const cy = Math.floor(MAP_HEIGHT / 2) * TILE_SIZE + 1;
        ctx.fillStyle = "#ffffff";
        ctx.fillText(text, cx, cy);
    }

    // Main loop
    function loop(ts) {
        // Advance a client-side tick counter to drive smoothing timing
        gameTick = (gameTick + 1) | 0;
        draw();
        requestAnimationFrame(loop);
    }

    // Keyboard events
    window.addEventListener("keydown", (e) => {
        if (e.key === "q" || e.key === "Q") { disconnect(); return; }
        if (e.key === " ") e.preventDefault();
        keyState.add(e.key);
    });
    window.addEventListener("keyup", (e) => { keyState.delete(e.key); });

    btnConnect.addEventListener("click", () => { connectAbort = false; connect(); });
    btnDisconnect.addEventListener("click", disconnect);

    // Start
    requestAnimationFrame(loop);
    // Auto-connect on load to default
    serverUrlInput.value = DEFAULT_ENDPOINT;
    connect();
})();
</script>
</body>
</html>


